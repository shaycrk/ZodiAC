<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ZodiAC Rallye Builder</title>
    <link rel="shortcut icon" href="favicon.ico" />
    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 50%;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #content {
        background-color: #fff;
        padding: 2px;
        height: calc(50% - 5px);
        font-family: Helvetica;
      }

      h2 {
        margin: 0;
        padding: 0;
      }

      #errorMsg {
        width: calc(100% - 10px);
        height: 20px;
        line-height: 20px;
        font-family: Helvetica;
        font-size: 16px;
        margin: 3px;
        padding-left: 5px;
      }
      
      .errorStyle {
        background-color: red;
        color: white;
        font-weight: bold;
        text-align: center;
      }
      
      .nonErrorStyle {
        background-color: white;
      }

      #settings-container {
        float: left;
        height: calc(100% - 10px);
        width: calc(100% - 356px);
      }

      .editor-pane {
        height: calc(100% - 80px);
        width: calc(100% - 20px);
        vertical-align: top;
        overflow: scroll;
        font-family: Helvetica;
        padding: 2px;
        margin-left: 15px;
      }

      #settings {
        display: inline-block;
      }
      
      #settings-info {
        display: block;
      }
      
      #objectEditor {
        display: none;
      }
      
      #objectEditor-info {
        display: none;
      }
      
      #critiqueEditor {
        display: none;
      }
      
      #critiqueEditor-info {
        display: none;
      }

      #howto {
        display: inline-block;
        float: left;
        width: 350px;
        height: calc(100% - 10px);
        overflow: scroll;
        font-family: Helvetica;
        padding: 2px;
        background-color: lightgrey;
        border-right: 1px solid black;
      }

      #exportButton {
        font-size: 16px;
        font-weight: bold;
        color: #b00;
        display: inline-block;
        float: right;
      }

      #exportButton:hover {
        cursor: pointer;
      }

      #importButton {
        font-size: 16px;
        font-weight: bold;
        color: #00b;
        display: inline-block;
        float: right;
        margin-right: 10px;
      }

      #importButton:hover {
        cursor: pointer;
      }

      #loadJSON {
        display: none;
        font-size: 14px;
        padding-left: 20px;
        padding-top: 5px;
        margin-bottom: 15px;
      }

      #menu {
        background-color: #000;
        font-family: Helvetica;
        font-size: 16px;
      }
      #menu > ul {
        margin: 0;
        padding: 0;
        color: white;
        list-style-type: none;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #333;
      }
      li {
        float: left;
      }

      li a {
        display: block;
        color: white;
        text-align: center;
        padding: 17px 16px;
        text-decoration: none;
      }

      /* Change the link color to #111 (black) on hover */
      li a:hover {
        background-color: #111;
      }

      li a.active {
        background-color: #fff;
        color: #000;
      }

      .exportRallye, .importRallye {
        float: right;
        padding: 13px 16px;
      }
      
      #instUrlTable {
        border: none;
      }
      
      #instUrlTable td,th {
        border: none;
        padding: 3px;
      }
      
      .score-rule, .score-rule-template {
        align-items: stretch;
        margin-bottom: 15px;
        padding: 4px;
        font-size: 14px;
      }
      
      .score-rule-template {
        display: none;
      }
      
      .score-rule {
        display: flex;
      }

      .current-score-rule, .pending-score-rule {
        background-color: lightgray;
      }
      
      .pending-rm-score-rule {
        background-color: indianred;
      }
      
      .score-rule-drag {
        display: inline-block;
        width: 25px;
        cursor: grab;
      }
      
      .current-score-rule .score-rule-drag,
      .pending-score-rule .score-rule-drag {
        background-color: darkgray;
      }
      
      .pending-rm-score-rule .score-rule-drag {
        background-color: darkred;
      }
      
      .score-rule-item {
        display: inline-block;
        padding-left: 5px;
      }
      
      .score-rule-button-container {
        display: flex;
        align-items: center;
      }
      
      .score-rule-button {
        font-size: 16px;
        margin: 2px;
      }
      
      .score-rule-cms {
        width: 275px;
      }
      
      .score-rule-value {
        width: 60px;
      }
      
      .score-rule-reason {
        width: 400px;
      }

      .sortable-placeholder {
        height: 40px;
        width: calc(100% - 10px);
        border: 2px dashed darkgrey;
        margin: 0 0 0.75rem 0;
        position: relative;
        z-index: 6;
      }

    </style>
    <script src="//cdn.jsdelivr.net/npm/mobile-detect@1.4.3/mobile-detect.min.js"></script>
    <script>
      var md = new MobileDetect(window.navigator.userAgent);
      if (md.mobile()) {
        window.location.replace("mobile_message.html");
      }
    </script>

    <script
      src="https://code.jquery.com/jquery-3.3.1.min.js"
      integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
      crossorigin="anonymous"></script>
    
    <script
      src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js"
      integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU="
      crossorigin="anonymous"></script>
  </head>
  <body>
    <!--
    <div id="floating-panel">
      <input type="button" value="Toggle Street View" onclick="toggleStreetView();"></input>
    </div>
    -->
    <div id="map"></div>
    <div id="content">
      <div id="howto">
        <div id="settings-info">
          <h3>Settings Instructions</h3>
          <p>Use "Load Rallye" to continue working on a rallye you've saved previously (in JSON format). When you're finished editing, use "Export Rallye" to save your rallye to your computer. To export, a rallye must at least have a start, end, and name.</p>

          <p>Click on the map above to place a course marker, checkpoint, or the rallye starting & ending points; or click on an existing object to edit or remove it from your rallye.</p>
          
          <p>Setting the <b>Grid Offset</b> allows you to specify if the grid of the city's streets is tilted relative to the true compass directions so specifying "north", "south", "east", "west" for a heading will align to the city grid.</p>
          
          <p>The URLs of the general, route, and supplemental instructions should point PDF files (these are not required to export a rallye json, but will be needed to run the rallye).</p>
        </div>
        <div id="objectEditor-info">
          <h3>Object Editor Instructions</h3>
          <p>Click on the map above to indicate where you want to place an object, then choose the object type (coursemarker, checkpoint, rallye start, or rallye end) and set the object information in the form to the right.</p>
  
          <p>The <b>Heading</b> is the direction the car must be traveling to see the object (this may be either "north", "south", "east", "west", or as a number of degrees clockwise from north).</p>
          
          <p>The <b>Label</b> is required to identify coursemarkers and checkpoints (optionally, you can use "\n" to insert a new line, such as "E\n66").</p>
          
          <p>For a checkpoint, the <b>Checkpoint SI</b> is required to indicate a special instruction associated with the CP that will be displayed when clicking on it.</p>
          
          <p>Click <b>Preview</b> to see where your object will appear on the map and then <b>Confirm</b> to add it to your rallye.</p>
        </div>
        <div id="critiqueEditor-info">
          <h3>Score Values Instructions</h3>
          <p>Score rules associate recorded coursemarkers with point values. Click on <b>Add Score Rule</b> to create a new rule and fill in the values. Drag the score rules to reorder them.</p>
          
          <p><b>Recorded CMs</b> is a list of coursemarkers <b>all</b> of which the participant must have recorded to receive the points. Enter coursemarkers as letter-number combinations without any spaces (e.g., "E66" not "E 66" or "E\n66") and separate multiple CMs with commas.</p>
          
          <p><b>Non-Recorded CMs</b> is a list of coursemarkers <b>none</b> of which the participant must have recorded to receive the points.</p>
          
          <p><b>Example:</b> To reward 20 points for recording markers A27 and H20 but <b>not</b> recording PP6, you would list "A27, H20" as "recorded CMs" and "PP6" as "non-recorded CMs".</p>
          
          <p>Every score rule must include a value, reason, and either recorded or non-recorded coursemarkers (or both).</p>
        </div>
      </div>
      <div id="settings-container">

        <div id="menu">
          <ul>
            <li><a href="#" class="active" id="menu-settings" onClick="showEditor('settings');">Rallye Settings</a></li>
            <li><a href="#" id="menu-critiqueEditor" onClick="showEditor('critiqueEditor');">Score Values</a></li>
            <li><a href="#" id="menu-objectEditor" onClick="showEditor('objectEditor');">Object Editor</a></li>
            <li class="exportRallye">
              <input id="exportButton" type="button" value="Export Rallye" onclick="downloadRallye();" />
              <input id="importButton" type="button" value="Load Rallye" onclick="document.getElementById('fileinput').click();" />
            </li>
          </ul>
        </div>

        <div id="errorMsg"></div>

        <div id="settings" class="editor-pane">
          <div id="loadJSON">
            [Optional] Load an existing saved rallye:<br />
            <input type='file' id='fileinput' onchange='loadFile();' accept='.json,application/json,text/x-json' />
            <!-- <input type='button' id='btnLoad' value='Load' onclick='loadFile();' />-->
          </div>
          <p>Rallye Name: <input id="rallyeName" type="text" size=50 /></p>
          <p>Grid offset (clockwise degrees from north): <input id="northOffset" oninput="gridOffset();" size=10 value="-10" /></p>
          <table id="instUrlTable">
            <tr><td>General Instructions URL:</td><td><input id="giURL" type="text" size=60 /></td></tr>
            <tr><td>Route Instructions URL:</td><td><input id="riURL" type="text" size=60 /></td></tr>
            <tr><td>Supplemental Instructions URL:</td><td><input id="suppURL" type="text" size=60 /></td></tr>
          </table>
        </div>

        <div id="critiqueEditor" class="editor-pane">

          <div class="score-rule-template current-score-rule">
            <div class="score-rule-drag score-rule-item"></div>
            <div class="score-rule-cms score-rule-item">
              <div class="recorded-cms"><b>Recorded CMs:</b> <span class="rule-values"><input type="text" size=14 /></span></div>
              <div class="non-recorded-cms"><b>Non-Recorded CMs:</b> <span class="rule-values"><input type="text" size=10 /></span></div>
            </div>
            <div class="score-rule-value score-rule-item"><b>Value:</b><br /><span class="rule-values"><input type="text" size=2 /></span></div>
            <div class="score-rule-reason score-rule-item"><b>Reason:</b><br /><span class="rule-values"><input type="text" size=45 /></span></div>
            <div class="edit-links score-rule-button-container" id="test-edit-links">
              <input type="button" value="edit" class="score-rule-button" onclick="scoreButtonEdit(this);" />
              <input type="button" value="delete" class="score-rule-button" onclick="scoreButtonDelete(this);" />
            </div>
            <div class="apply-buttons score-rule-button-container">
              <input type="button" value="confirm" class="score-rule-button" onclick="scoreButtonConfirm(this);" />
              <input type="button" value="cancel" class="score-rule-button" onclick="scoreButtonCancel(this);" />
            </div>
          </div>

          <div id="score-rules-container">
          
          </div>

          <input id="add-score-rule-button" type="button" value="Add Score Rule" onclick="newScoreRule();" />

        </div>

        <div id="objectEditor" class="editor-pane">
          <p>Object Location (Lat, Lng): <span id="objectLocation"><span id="objectLat"></span><span id="objectLng"></span></span></p>
          <p>Type: <select id="objectType">
            <option value="cm">Course Marker</option>
            <option value="cp">Checkpoint</option>
            <option value="start">Rallye Start</option>
            <option value="end">Rallye End</option>
          </select></p>
          <p>Heading: <input id="objectHeading" type="text" size=7 style='margin-right: 15px;' /> Label: <input id="objectLabel" type="text" size=10 /></p>
          <p>Checkpoint SI:<br />
          <textarea id="cpSI" cols=41 rows=4></textarea></p>
          <p>
            <input type="button" value="Preview" onclick="handleObject();" />
            <input type="button" value="Confirm" onclick="handleObject(confirm=true);" />
          </p>
        </div>

      </div>
    </div>

<script>
var mapObj;
var currMarker;
var currArrow;
var openInfoWindow;

var rallyeStart, rallyeEnd;
var courseMarkers = {};
var checkpoints = {};

// some variables for headings
// Winters grid about -10 deg off true north,
// so traveling north is 350 and so on
var north = 0
var south = 180
var west = 270
var east = 90

var startLoc = {lat: 38.5261, lng: -121.9648};
//var startLoc = {lat: 38.483338, lng: -121.998583}; //end
var startHeading = 240;

function classLoader() {

class DirectionalMarker extends google.maps.Marker {

  // distance in meters, angle in degrees to one side
  constructor(markerOpts, visibleHeading, visibleDistance=50, visibleAngle=60) {
    super(markerOpts);
    this.visibleDistance = visibleDistance;
    this.visibleHeading = visibleHeading;
    this.visibleAngle = visibleAngle;
  }

  checkVisibility(latlong, heading) {
    if (
      (this.distanceTo(latlong) <= this.visibleDistance ) &&
      (this.angleBetween(heading) <= this.visibleAngle)
    ) {
      this.setVisible(true);
    } else {
      this.setVisible(false);
    }
  }
  
  distanceTo(latlong) {
    return google.maps.geometry.spherical.computeDistanceBetween(
    latlong, this.getPosition());
  }
  
  angleBetween(heading) {
    var diff = Math.abs(this.visibleHeading - heading);
    return Math.min(360-diff, diff);
  }

}

return DirectionalMarker;
}

function editObj(objType, title) {
  
  showEditor('objectEditor');

  var lat, lng, selectIdx, heading, label, cpSI;
  title = title.replace("\\n", "\n");

  switch (objType) {
    case 'cm':
      lat = courseMarkers[title]['lat'];
      lng = courseMarkers[title]['lng'];
      selectIdx = 0;
      heading = courseMarkers[title]['rawHeading'];
      label = title;
      cpSI = '';
      break;
    case 'cp':
      lat = checkpoints[title]['lat'];
      lng = checkpoints[title]['lng'];
      selectIdx = 1;
      heading = checkpoints[title]['rawHeading'];
      label = title;
      cpSI = checkpoints[title]['checkpoint_si'];
      break;
    case 'start':
      lat = rallyeStart['lat'];
      lng = rallyeStart['lng'];
      selectIdx = 2;
      heading = rallyeStart['rawHeading'];
      label = '';
      cpSI = '';
      break;
    case 'end':
      lat = rallyeEnd['lat'];
      lng = rallyeEnd['lng'];
      selectIdx = 3;
      heading = rallyeEnd['rawHeading'];
      label = '';
      cpSI = '';
      break;
  }

  document.getElementById("objectType").selectedIndex = selectIdx;
  setLatLng(lat, lng);
  document.getElementById("objectHeading").value = heading;
  document.getElementById("objectLabel").value = label.replace("\n", "\\n");
  document.getElementById("cpSI").value = cpSI;

  // remove the existing object
  removeObj(objType, title);

  // replace it with a preview from the editor
  handleObject();
}

function removeObj(objType, title) {
  title = title.replace("\\n", "\n");

  if (openInfoWindow) {
    openInfoWindow.close();
    openInfoWindow = null;
  }

  switch (objType) {
    case 'cm':
      courseMarkers[title]['marker_object'].setVisible(false);
      courseMarkers[title]['arrow_object'].setVisible(false);
      delete courseMarkers[title];
      break;
    case 'cp':
      checkpoints[title]['marker_object'].setVisible(false);
      checkpoints[title]['arrow_object'].setVisible(false);
      delete checkpoints[title];
      break;
    case 'start':
      rallyeStart['arrow_object'].setVisible(false);
      rallyeStart = null;
      break;
    case 'end':
      rallyeEnd['arrow_object'].setVisible(false);
      rallyeEnd = null;
      break;
  }
}

function removeAll() {

  Object.keys(courseMarkers).forEach(function(key) {
    removeObj('cm', key);
  });

  Object.keys(checkpoints).forEach(function(key) {
    removeObj('cp', key);
  });

  if (rallyeStart) {
    removeObj('start', '');
  }

  if (rallyeEnd) {
    removeObj('end', '');
  }

}

function placeCP(map, lat, lng, heading, title, cpSI, iconScale=1.0) {
  DirectionalMarker = classLoader();

  // sign size to display (pixels)
  var cpWidth = 30*iconScale;
  var cpHeight = 45*iconScale;
  var cpIcon = {
    url: 'https://shaycrk.files.wordpress.com/2018/12/checkpoint.gif',
    scaledSize: new google.maps.Size(cpWidth, cpHeight)
  };
  
  var marker = new DirectionalMarker({
      position: {lat: lat, lng: lng},
      map: map,
      icon: cpIcon,
      title: title
    },
    heading
    )

  var infoWindowObject = new google.maps.InfoWindow;

  var infoWindowHTML = '<b>SI:</b> ' + cpSI;
  infoWindowHTML += '<hr><a href="#" onClick="editObj(\'cp\', \''+title.replace("\n", "\\n")+'\');">Edit</a> | ';
  infoWindowHTML += '<a href="#" onClick="removeObj(\'cp\', \''+title.replace("\n", "\\n")+'\');">Remove</a><br />';

  google.maps.event.addListener(marker, 'click', function() {
    if (openInfoWindow) {
      openInfoWindow.close();
    }
    infoWindowObject.setContent(infoWindowHTML);
    infoWindowObject.open(map, marker);
    openInfoWindow = infoWindowObject;
  });

  return marker;
}

function placeCM(map, lat, lng, heading, title, iconScale=1.0) {
  DirectionalMarker = classLoader();

  // course marker size to display (pixels)
  var cmWidth = 35*iconScale
  var cmHeight = 150*iconScale
  var cmIcon = {
    url: 'https://shaycrk.files.wordpress.com/2018/12/cm_on_pole.gif',
    scaledSize: new google.maps.Size(cmWidth, cmHeight)
  };

  var marker = new DirectionalMarker({
        position: {lat: lat, lng: lng},
        map: map,
        icon: cmIcon,
        title: title
      },
      heading
      );

  var infoWindowObject = new google.maps.InfoWindow;

  var infoWindowHTML = title.replace("\n", "<br \>");
  infoWindowHTML += '<hr><a href="#" onClick="editObj(\'cm\', \''+title.replace("\n", "\\n")+'\');">Edit</a> | ';
  infoWindowHTML += '<a href="#" onClick="removeObj(\'cm\', \''+title.replace("\n", "\\n")+'\');">Remove</a><br />';

  google.maps.event.addListener(marker, 'click', function() {
    if (openInfoWindow) {
      openInfoWindow.close();
    }
    infoWindowObject.setContent(infoWindowHTML);
    infoWindowObject.open(map, marker);
    openInfoWindow = infoWindowObject;
  });

  return marker;
}

function placeArrow(map, lat, lng, angle, height, title=null, color="#a0f") {
  // place an arrow over a map marker, rotated to point a certain direction (e.g., the
  // direction a CM is facing, which is its visibleHeading - 180 deg). It looks like
  // translation by `anchor` is done after rotating the coordinate system, so have
  // to rotate the coordinates of the translation as well. Finally, because rotations
  // happen around the tip of the arrow, translate back (in the original coordinates)
  // by the size of the arrow to have the center end up where we want it.

  // Two notes that add a little complexity:
  //  1. The coordinate system appears to be left-handed, with greater x-values
  //     further to the west
  //  2. rotations are taken clockwise from due north (the y-axis) as opposed to
  //     polar-coordinates that measure counter-clockwise from the x-axis
  var arrowCenter = new google.maps.Point(0, -2);
  return new google.maps.Marker({
    position: {lat: lat, lng: lng},
    icon: {
      path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
      scale: 2,
      strokeColor: color,
      fillColor: color,
      fillOpacity: 1.0,
      anchor: addPoints(rotateCoordinates(0, height, -1*angle), arrowCenter, subtract=true),
      rotation: angle
    },
    zIndex: 9999,
    title: title,
    map: map
  });
}

function arrowInfoWindow(map, marker, objType, title, infoHTML=null) {
  var infoWindowObject = new google.maps.InfoWindow;

  var infoWindowHTML = infoHTML || title
  infoWindowHTML = infoWindowHTML.replace("\n", "<br \>");
  infoWindowHTML += '<hr><a href="#" onClick="editObj(\''+objType+'\', \''+title.replace("\n", "\\n")+'\');">Edit</a> | ';
  infoWindowHTML += '<a href="#" onClick="removeObj(\''+objType+'\', \''+title.replace("\n", "\\n")+'\');">Remove</a><br />';

  google.maps.event.addListener(marker, 'click', function() {
    if (openInfoWindow) {
      openInfoWindow.close();
    }
    infoWindowObject.setContent(infoWindowHTML);
    infoWindowObject.open(map, marker);
    openInfoWindow = infoWindowObject;
  });
}

function placeArrows(map) {

  courseMarkers.forEach(function(cm) {
    placeArrow(map, cm[0], cm[1], cm[3] - 180, 13, cm[2]);
  });

  checkpoints.forEach(function(cp) {
    placeArrow(map, cp[0], cp[1], cp[3] - 180, 9, cp[2]);
  });

  otherObjects.forEach(function(obj) {
    placeArrow(map, obj[0], obj[1], obj[6] - 180, 13);
  });

}

function getQueryVariable(variable)
{
       var query = window.location.search.substring(1);
       var vars = query.split("&");
       for (var i=0;i<vars.length;i++) {
               var pair = vars[i].split("=");
               if(pair[0] == variable){return pair[1];}
       }
       return(false);
}

function addPoints(p1, p2, subtract=false) {
  var fac = 1.0;
  if (subtract) {
    fac = -1.0;
  }
  return new google.maps.Point(p1.x + fac*p2.x, p1.y + fac*p2.y)
}

function rotateCoordinates(x, y, phi) {
  // phi is a clockwise rotation of the coordinate system,
  // expressed in degrees

  // handle the origin as a special case:
  if ((Math.abs(x) < 1e-6) && (Math.abs(y) < 1e-6)) {
    return new google.maps.Point(0, 0);
  }

  var r = Math.sqrt(x**2 + y**2)
  var theta = Math.atan(y/x)
  if (x < 0) {
    // correct for arctan range
    theta = theta + Math.PI
  }
  var x_prime = r*Math.cos(theta + phi*Math.PI/180)
  var y_prime = r*Math.sin(theta + phi*Math.PI/180)
  return new google.maps.Point(x_prime, y_prime)
}

function initMap() {
  gridOffset();
  initGoogleMap();
}

// map version: view for the rallye master
function initGoogleMap() {
  var map = new google.maps.Map(
    document.getElementById('map'), {
    center: startLoc,
    zoom: 16,
    streetViewControl: true,
    mapTypeControl: false,
    rotateControl: false,
    draggableCursor: 'crosshair'
  });
  mapObj = map;
  
  map.addListener('click', function(e) {
    if (openInfoWindow) {
      openInfoWindow.close();
      openInfoWindow = null;
    }
    handleMapClick(e.latLng.lat(), e.latLng.lng());
  });
}

</script>

<script>

function showEditor(tabName) {
  allEditors = ['settings', 'objectEditor', 'critiqueEditor'];
  
  [].forEach.call(allEditors, function(e) {
    document.getElementById(e).style.display = 'none';
    document.getElementById(e+'-info').style.display = 'none';
  });
  
  document.getElementById(tabName).style.display = 'inline-block';
  document.getElementById(tabName + '-info').style.display = 'block';
  
  // remove active class from any current menu item (using array prototype forEach)
  var elms = document.getElementsByClassName("active");
  [].forEach.call(elms, function(s) { s.classList.remove("active"); });

  // add the active class to the clicked menu item
  document.getElementById('menu-'+tabName).classList.add("active");
  
  if (tabName != 'objectEditor') {
    clearObjectEditor();
  }
}

function handleMapClick(lat, lng) {
  
  showEditor('objectEditor');
  
  setLatLng(lat, lng);
  
  // if you're currently previewing an object, update the location
  if (currMarker || currArrow) {
    handleObject();
  }
}

function setLatLng(lat, lng) {
  if (lat) {
    document.getElementById("objectLocation").innerHTML = '(<span id="objectLat"></span>, <span id="objectLng"></span>)';
  } else {
    document.getElementById("objectLocation").innerHTML = '<span id="objectLat"></span><span id="objectLng"></span>';
  }
  document.getElementById("objectLat").innerHTML = lat;
  document.getElementById("objectLng").innerHTML = lng;
}

function parseHeading(rawHeading) {
  var heading;
  switch (rawHeading) {
    case 'north':
      heading = north;
      break;
    case 'south':
      heading = south;
      break;
    case 'east':
      heading = east;
      break;
    case 'west':
      heading = west;
      break;
    default:
      heading = parseFloat(rawHeading);
  }
  return heading;
}

function gridOffset() {
  var offset = parseFloat(document.getElementById("northOffset").value) || 0;
  north = 0 + offset;
  south = 180 + offset;
  east = 90 + offset;
  west = 270 + offset;

  Object.keys(courseMarkers).forEach(function(key) {
    courseMarkers[key]['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj,
      courseMarkers[key]['lat'],
      courseMarkers[key]['lng'],
      parseHeading(courseMarkers[key]['rawHeading'])-180,
      13,
      courseMarkers[key]['label']
    );
    courseMarkers[key]['arrow_object'] = newArrow;
    arrowInfoWindow(mapObj, newArrow, 'cm', courseMarkers[key]['label']);
  });

  Object.keys(checkpoints).forEach(function(key) {
    checkpoints[key]['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj,
      checkpoints[key]['lat'],
      checkpoints[key]['lng'],
      parseHeading(checkpoints[key]['rawHeading'])-180,
      9,
      checkpoints[key]['label']
    );
    checkpoints[key]['arrow_object'] = newArrow;
    arrowInfoWindow(mapObj, newArrow, 'cp', checkpoints[key]['label'], '<b>SI:</b> ' + checkpoints[key]['checkpoint_si']);
  });

  if (rallyeStart) {
    rallyeStart['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj,
      rallyeStart['lat'],
      rallyeStart['lng'],
      parseHeading(rallyeStart['rawHeading']),
      0,
      'Rallye Start',
      "#006400"
    );
    rallyeStart['arrow_object'] = newArrow;
    arrowInfoWindow(mapObj, newArrow, 'start', 'Rallye Start');
  }

  if (rallyeEnd) {
    rallyeEnd['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj,
      rallyeEnd['lat'],
      rallyeEnd['lng'],
      parseHeading(rallyeEnd['rawHeading'])-180,
      0,
      'Rallye End',
      "#640000"
    );
    rallyeEnd['arrow_object'] = newArrow;
    arrowInfoWindow(mapObj, newArrow, 'end', 'Rallye End');
  }

}

function showError(errorText) {
  document.getElementById("errorMsg").innerHTML = errorText;
  if (errorText) {
    document.getElementById("errorMsg").classList.remove("nonErrorStyle");
    document.getElementById("errorMsg").classList.add("errorStyle");
  } else {
    document.getElementById("errorMsg").classList.remove("errorStyle");
    document.getElementById("errorMsg").classList.add("nonErrorStyle");
  }
}

function handleObject(confirm=false) {
  var objType = document.getElementById("objectType").value;
  var lat = parseFloat(document.getElementById("objectLat").textContent);
  var lng = parseFloat(document.getElementById("objectLng").textContent);
  var rawHeading = document.getElementById("objectHeading").value.toLowerCase();
  var heading = parseHeading(rawHeading);
  var label = document.getElementById("objectLabel").value.replace("\\n", "\n");
  var cpSI = document.getElementById("cpSI").value;

  // clear any current error
  showError('');

  if (!lat || !lng || rawHeading == '') {
    showError('ERROR: Specify a location and heading!');
    return false;
  }

  if (currMarker) {
    currMarker.setVisible(false);
    currMarker = null;
  }

  if (currArrow) {
    currArrow.setVisible(false);
    currArrow = null;
  }

  switch (objType) {
    case 'cm':
      label = label.toUpperCase();
      if (courseMarkers[label]) {
        showError('ERROR: Course marker '+label+' already exists!');
      } else if (!label) {
        showError('ERROR: Must specify a label for the course marker');
      } else {
        currMarker = placeCM(mapObj, lat, lng, heading, label, 0.3);
        currArrow = placeArrow(mapObj, lat, lng, heading-180, 13, label);
        arrowInfoWindow(mapObj, currArrow, 'cm', label);
        currMarker.setAnimation(google.maps.Animation.BOUNCE);
        if (confirm) {
          currMarker.setAnimation(null);
          courseMarkers[label] = {
            'label': label,
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'marker_object': currMarker,
            'arrow_object': currArrow
          };
        }
      }
      break;
    case 'cp':
      if (checkpoints[label]) {
        showError('ERROR: Checkpoint '+label+' already exists!');
      } else if (!label || !cpSI) {
        showError('ERROR: Specify a label and SI for the checkpoint');
      } else {
        currMarker = placeCP(mapObj, lat, lng, heading, label, cpSI, 0.3);
        currArrow = placeArrow(mapObj, lat, lng, heading-180, 9, label);
        arrowInfoWindow(mapObj, currArrow, 'cp', label, '<b>SI:</b> ' + cpSI);
        currMarker.setAnimation(google.maps.Animation.BOUNCE);
        if (confirm) {
          currMarker.setAnimation(null);
          checkpoints[label] = {
            'label': label,
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'checkpoint_si': cpSI,
            'marker_object': currMarker,
            'arrow_object': currArrow
          };
        }
      }
      break;
    case 'start':
      if (rallyeStart) {
        showError("ERROR: Start already exists!");
      } else {
        currArrow = placeArrow(mapObj, lat, lng, heading, 0, 'Rallye Start', "#006400");
        arrowInfoWindow(mapObj, currArrow, 'start', 'Rallye Start');
        currArrow.setAnimation(google.maps.Animation.BOUNCE);
        if (confirm) {
          currArrow.setAnimation(null);
          rallyeStart = {
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'arrow_object': currArrow
          }
        }
      }
      break;
    case 'end':
      if (rallyeEnd) {
        showError("ERROR: End already exists!");
      } else {
        currArrow = placeArrow(mapObj, lat, lng, heading-180, 0, 'Rallye End', "#640000");
        arrowInfoWindow(mapObj, currArrow, 'end', 'Rallye End');
        currArrow.setAnimation(google.maps.Animation.BOUNCE);
        if (confirm) {
          currArrow.setAnimation(null);
          rallyeEnd = {
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'arrow_object': currArrow
          }
        }
      }
      break;
  }

  if (confirm) {
    // these have been added to the global vars, so remove them
    currMarker = null;
    currArrow = null;

    // reset the object editor form
    document.getElementById("objectType").selectedIndex = 0;
    setLatLng('', '');
    document.getElementById("objectHeading").value = '';
    document.getElementById("objectLabel").value = '';
    document.getElementById("cpSI").value = '';
  }
}

function rallyeToJSON() {
  var rallyeName = document.getElementById("rallyeName").value;
  if (!rallyeStart || !rallyeName || !rallyeEnd) {
    showError('ERROR: Set a name, starting point, and ending point before exporting!');
    return 'ERROR';
  }
  
  if (currArrow || currMarker || scoreRuleMode) {
    showError('ERROR: Confirm or cancel pending changes before exporting!');
    return 'ERROR';
  }

  var cms = [];
  Object.keys(courseMarkers).forEach(function(key) {
    cms.push([
      courseMarkers[key]['lat'],
      courseMarkers[key]['lng'],
      courseMarkers[key]['label'],
      courseMarkers[key]['rawHeading']
      ]);
  });

  var cps = [];
  Object.keys(checkpoints).forEach(function(key) {
    cps.push([
      checkpoints[key]['lat'],
      checkpoints[key]['lng'],
      checkpoints[key]['label'],
      checkpoints[key]['rawHeading'],
      '<b>SI:</b> ' + checkpoints[key]['checkpoint_si']
      ]);
  });
  
  var scoreRuleDivs = document.getElementById('score-rules-container').children;
  var scoreRules = [];
  for (let scoreRuleDiv of scoreRuleDivs) {
    scoreRules.push(readScoreRuleValues(scoreRuleDiv));
  }

  var d = {
    'rallyeName': rallyeName,
    'gridOffset': parseFloat(document.getElementById("northOffset").value) || 0,
    'generalsURL': document.getElementById("giURL").value,
    'routeURL': document.getElementById("riURL").value,
    'suppsURL': document.getElementById("suppURL").value,
    'rallye_start': {
      lat: rallyeStart['lat'],
      lng: rallyeStart['lng'],
      heading: rallyeStart['rawHeading']
    },
    'rallye_end': {
      lat: rallyeEnd['lat'],
      lng: rallyeEnd['lng'],
      heading: rallyeEnd['rawHeading']
    },
    'courseMarkers': cms,
    'checkpoints': cps,
    'score_values': scoreRules
  }

  // json string with "pretty print" enabled
  return JSON.stringify(d, null, 2);
}

// from: https://stackoverflow.com/questions/14964035/how-to-export-javascript-array-info-to-csv-on-client-side
// The download function takes a data string, the filename and mimeType as parameters
function downloadFile(content, fileName, mimeType) {
  var a = document.createElement('a');
  mimeType = mimeType || 'application/octet-stream';

  if (navigator.msSaveBlob) { // IE10
    navigator.msSaveBlob(new Blob([content], {
      type: mimeType
    }), fileName);
  } else if (URL && 'download' in a) { //html5 A[download]
    a.href = URL.createObjectURL(new Blob([content], {
      type: mimeType
    }));
    a.setAttribute('download', fileName);
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  } else {
    location.href = 'data:application/octet-stream,' + encodeURIComponent(content); // only this mime type is supported
  }
}

function downloadRallye() {
  var fileName = document.getElementById("rallyeName").value + '.json';
  var jsonData = rallyeToJSON();
  if (jsonData != 'ERROR') {
    downloadFile(jsonData, fileName, 'text/plain;encoding:utf-8');
  }
}

</script>


<script>
  var scoreRuleMode = null;
  var scoreRuleRevert = null;

  $(document).ready(function() {
    $("#score-rules-container").sortable({
      
      axis: "y",
      revert: true,
      scroll: true,
      scrollSensitivity: 20,
      placeholder: "sortable-placeholder",
      cursor: "move"
    
    });
  });


  function newScoreRule(fillValues=null) {

    var cloned = document.getElementsByClassName('score-rule-template')[0].cloneNode(true);
    cloned.classList.remove('score-rule-template');
    cloned.classList.add('score-rule');

    cloned.classList.remove('current-score-rule');
    cloned.classList.add('pending-score-rule');

    if (fillValues) {
      // if values were passed, set form elements with them
      setScoreInputValues(cloned, fillValues);
    }

    document.getElementById('score-rules-container').appendChild(cloned);
    setScoreRuleMode('new_rule', cloned);

    if (fillValues) {
      // if values were passed, confim them
      scoreButtonConfirm(cloned);
    }
  }
  
  
  function setScoreInputValues(scoreRuleDiv, fillValues) {
    scoreRuleDiv.getElementsByClassName('recorded-cms')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value = (fillValues['includeCMs'] || []).join(', ').toUpperCase();
  
    scoreRuleDiv.getElementsByClassName('non-recorded-cms')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value = (fillValues['excludeCMs'] || []).join(', ').toUpperCase();
  
    scoreRuleDiv.getElementsByClassName('score-rule-value')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value = fillValues['value'];
  
    scoreRuleDiv.getElementsByClassName('score-rule-reason')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value = fillValues['reason'];
  }


  function readScoreRuleValues(scoreRuleDiv) {
    var fillValues = {};

    var includeCMs = scoreRuleDiv.getElementsByClassName('recorded-cms')[0].getElementsByClassName('rule-values')[0].textContent;
    if (includeCMs) {
      fillValues['includeCMs'] = includeCMs.split(',').map(function(elm) { return elm.trim().toUpperCase(); });
    }

    var excludeCMs = scoreRuleDiv.getElementsByClassName('non-recorded-cms')[0].getElementsByClassName('rule-values')[0].textContent;
    if (excludeCMs) {
      fillValues['excludeCMs'] = excludeCMs.split(',').map(function(elm) { return elm.trim().toUpperCase(); });
    }

    fillValues['value'] = parseFloat(scoreRuleDiv.getElementsByClassName('score-rule-value')[0].getElementsByClassName('rule-values')[0].textContent);

    fillValues['reason'] = scoreRuleDiv.getElementsByClassName('score-rule-reason')[0].getElementsByClassName('rule-values')[0].textContent;
    
    return fillValues;
  }


  function setScoreRuleMode(ruleMode, scoreRuleDiv) {
    scoreRuleMode = ruleMode;

    if (ruleMode) {

      var buttonDivs = document.getElementById('score-rules-container').getElementsByClassName('edit-links');
      for (let buttonDiv of buttonDivs) {
        buttonDiv.style.display = 'none';
      }
      document.getElementById('add-score-rule-button').style.display = 'none';
      scoreRuleDiv.getElementsByClassName('apply-buttons')[0].style.display = 'flex';

    } else {

      var buttonDivs = document.getElementById('score-rules-container').getElementsByClassName('edit-links');
      for (let buttonDiv of buttonDivs) {
        buttonDiv.style.display = 'flex';
      }
      buttonDivs = document.getElementById('score-rules-container').getElementsByClassName('apply-buttons');
      for (let buttonDiv of buttonDivs) {
        buttonDiv.style.display = 'none';
      }
      document.getElementById('add-score-rule-button').style.display = 'inline-block';

    }
    
    scoreRuleMode = ruleMode;
  }


  function scoreButtonConfirm(scoreRuleDiv) {

    if (['INPUT', 'BUTTON'].includes(scoreRuleDiv.tagName)) {
      // if called from a button click, step back out to containing score rule
      scoreRuleDiv = scoreRuleDiv.parentElement.parentElement;
    }

    if (scoreRuleMode == 'remove_rule') {
      
      // if confirming a remove action, just remove the score rule div
      scoreRuleDiv.remove();

    } else {
    
      // Check that at least include or exclude CMs, value, and reason are set
      var recordedCMs = scoreRuleDiv.getElementsByClassName('recorded-cms')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value;
      var nonrecordedCMs = scoreRuleDiv.getElementsByClassName('non-recorded-cms')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value;
      var ruleValue = scoreRuleDiv.getElementsByClassName('score-rule-value')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value;
      var ruleReason = scoreRuleDiv.getElementsByClassName('score-rule-reason')[0].getElementsByClassName('rule-values')[0].getElementsByTagName('input')[0].value;
      if (!ruleValue || !ruleReason || (!recordedCMs && !nonrecordedCMs)) {
        showError('Must set a value, reason, and either recorded or non-recorded CMs.');
        return;
      }
  
      // turn form elements back into text
      ruleValuesElms = scoreRuleDiv.getElementsByClassName('rule-values');
      for (let rv of ruleValuesElms) {
        rv.innerHTML = rv.getElementsByTagName('input')[0].value;
        // ensure CMs are upper case so scoring will match up (unfortunately, this means no upper/lower gimmicks,
        // but seems like the safer general case?)
        if (rv.parentElement.parentElement.classList.contains('score-rule-cms')) {
          rv.innerHTML = rv.textContent.toUpperCase();
        }
      }

      // remove pending class and add current
      scoreRuleDiv.classList.remove('pending-score-rule');
      scoreRuleDiv.classList.add('current-score-rule');

    }

    // unset the rule mode
    showError('');
    scoreRuleRevert = null;
    setScoreRuleMode(null, scoreRuleDiv);
  }


  function scoreButtonDelete(scoreRuleDiv) {

    if (['INPUT', 'BUTTON'].includes(scoreRuleDiv.tagName)) {
      // if called from a button click, step back out to containing score rule
      scoreRuleDiv = scoreRuleDiv.parentElement.parentElement;
    }
    
    scoreRuleDiv.classList.remove('current-score-rule');
    scoreRuleDiv.classList.add('pending-rm-score-rule');

    showError('');
    setScoreRuleMode('remove_rule', scoreRuleDiv);
 
  }
  
  
  function scoreButtonCancel(scoreRuleDiv) {

    if (['INPUT', 'BUTTON'].includes(scoreRuleDiv.tagName)) {
      // if called from a button click, step back out to containing score rule
      scoreRuleDiv = scoreRuleDiv.parentElement.parentElement;
    }
    
    switch (scoreRuleMode) {
      
      case 'remove_rule':
        // cancel remove rule => return to current class, unset score rule mode
        scoreRuleDiv.classList.remove('pending-rm-score-rule');
        scoreRuleDiv.classList.add('current-score-rule');

        showError('');
        setScoreRuleMode(null, scoreRuleDiv);

        break;
      
      case 'new_rule':
        // cancel rule creation => remove newly created rule
        scoreRuleMode = 'remove_rule';
        scoreButtonConfirm(scoreRuleDiv);
        break;
      
      case 'edit_rule':
        // cancel rule edit => replace with scored revert values
        setScoreInputValues(scoreRuleDiv, scoreRuleRevert);
        scoreButtonConfirm(scoreRuleDiv);
        break;
    }

  }
  
  
  function scoreButtonEdit(scoreRuleDiv) {

    if (['INPUT', 'BUTTON'].includes(scoreRuleDiv.tagName)) {
      // if called from a button click, step back out to containing score rule
      scoreRuleDiv = scoreRuleDiv.parentElement.parentElement;
    }

    scoreRuleDiv.classList.remove('current-score-rule');
    scoreRuleDiv.classList.add('pending-score-rule');

    // read existing values from spans
    var fillValues = readScoreRuleValues(scoreRuleDiv);

    // create input fields
    scoreRuleDiv.getElementsByClassName('recorded-cms')[0].getElementsByClassName('rule-values')[0].innerHTML = '<input type="text" size=14 />';
    scoreRuleDiv.getElementsByClassName('non-recorded-cms')[0].getElementsByClassName('rule-values')[0].innerHTML = '<input type="text" size=10 />';
    scoreRuleDiv.getElementsByClassName('score-rule-value')[0].getElementsByClassName('rule-values')[0].innerHTML = '<input type="text" size=2 />';
    scoreRuleDiv.getElementsByClassName('score-rule-reason')[0].getElementsByClassName('rule-values')[0].innerHTML = '<input type="text" size=45 />';

    // fill out input fields with values
    setScoreInputValues(scoreRuleDiv, fillValues);
    
    //store revert values to globals to allow for canceling
    scoreRuleRevert = fillValues;

    showError('');
    setScoreRuleMode('edit_rule', scoreRuleDiv);
  }


  
</script>

<script type="text/javascript">

  // from: https://stackoverflow.com/questions/7346563/loading-local-json-file
  function loadFile() {
    var input, file, fr;

    if (typeof window.FileReader !== 'function') {
      alert("The file API isn't supported on this browser yet.");
      return;
    }

    input = document.getElementById('fileinput');
    if (!input) {
      alert("Um, couldn't find the fileinput element.");
    }
    else if (!input.files) {
      alert("This browser doesn't seem to support the `files` property of file inputs.");
    }
    else if (!input.files[0]) {
      alert("Please select a file before clicking 'Load'");
    }
    else {
      file = input.files[0];
      fr = new FileReader();
      fr.onload = receivedText;
      fr.readAsText(file);
    }

    function receivedText(e) {
      let lines = e.target.result;
      var rallyeDict = JSON.parse(lines);
      rallyeFromDict(rallyeDict);

    }
  }

  function rallyeFromDict(rallyeDict) {
    // remove any the existing objects to replace with loaded ones
    removeAll();

    document.getElementById("rallyeName").value = rallyeDict['rallyeName'];

    document.getElementById("northOffset").value = rallyeDict['gridOffset'];
    gridOffset();

    document.getElementById("giURL").value = rallyeDict['generalsURL'];
    document.getElementById("riURL").value = rallyeDict['routeURL'];
    document.getElementById("suppURL").value = rallyeDict['suppsURL'];

    var lat, lng, selectIdx, heading, label, cpSI;

    lat = rallyeDict['rallye_start']['lat'];
    lng = rallyeDict['rallye_start']['lng'];
    heading = rallyeDict['rallye_start']['heading'];
    setEditorValues(lat, lng, heading, '', '', 'start');
    handleObject(confirm=true);
    mapObj.setCenter({lat: lat, lng: lng});

    lat = rallyeDict['rallye_end']['lat'];
    lng = rallyeDict['rallye_end']['lng'];
    heading = rallyeDict['rallye_end']['heading'];
    setEditorValues(lat, lng, heading, '', '', 'end');
    handleObject(confirm=true);

    rallyeDict['courseMarkers'].forEach(function(cm) {
      setEditorValues(cm[0], cm[1], cm[3], cm[2], '', 'cm');
      handleObject(confirm=true);
    });

    rallyeDict['checkpoints'].forEach(function(cp) {
      setEditorValues(cp[0], cp[1], cp[3], cp[2], cp[4].replace('<b>SI:</b> ', ''), 'cp');
      handleObject(confirm=true);
    });
    
    rallyeDict['score_values'].forEach(function(sv) {
      newScoreRule(sv);
    });

  }

  function setEditorValues(lat, lng, heading, label, cpSI, objType) {
    var selectIdx;
    switch (objType) {
      case 'cm':
        selectIdx = 0;
        break;
      case 'cp':
        selectIdx = 1;
        break;
      case 'start':
        selectIdx = 2;
        break;
      case 'end':
        selectIdx = 3;
        break;
    }
    document.getElementById("objectType").selectedIndex = selectIdx;
    setLatLng(lat, lng);
    document.getElementById("objectHeading").value = heading;
    document.getElementById("objectLabel").value = label.replace("\n", "\\n");
    document.getElementById("cpSI").value = cpSI;
  }
  
  function clearObjectEditor() {
    if (currMarker) {
      currMarker.setMap(null);
      currMarker = null;
    }
    if (currArrow) {
      currArrow.setMap(null);
      currArrow = null;
    }
    setEditorValues('', '', '', '', '', 'cm');
  }

</script>

    <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC3-5-mUDJ2dfNR3l-8u_g2_XCBOeNbJvU&libraries=geometry&callback=initMap">
    </script>
  </body>
