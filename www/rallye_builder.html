<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ZodiAC Rallye Builder</title>
    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 50%;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #floating-panel {
        position: absolute;
        top: 10px;
        left: 25%;
        z-index: 5;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #999;
        text-align: center;
        font-family: 'Roboto','sans-serif';
        line-height: 30px;
        padding-left: 10px;
      }
      #floating-panel {
        margin-left: -100px;
      }
      #menu {
        background-color: #000;
        font-family: Helvetica;
      }
      #menu > ul {
        margin: 0;
        padding: 0;
        color: white;
        list-style-type: none;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #333;
      }
      li {
        float: left;
      }

      li a {
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
      }

      /* Change the link color to #111 (black) on hover */
      li a:hover {
        background-color: #111;
      }

      li a.active {
        background-color: #fff;
        color: #000;
      }

      #content {
        background-color: #fff;
        padding: 2px;
        height: 40%;
        font-family: Helvetica;
      }

      #instructions {
        width: 78%;
        height: 100%;
        display: inline-block;
        vertical-align: top;
        overflow: scroll;
      }

      #scoresheet {
        width: 20%;
        height: 100%;
        display: inline-block;
        vertical-align: top;
        overflow: scroll;
        border-left: 1px solid black;
        padding-left: 7px;
      }

      h2 {
        margin: 0;
        padding: 0;
      }

      .scoreInput {
        float: right;
        padding: 13px 16px;
      }

      .recordedCM {
        margin-bottom: 2px;
        padding: 1px;
        background-color: #f0f0f0;
        border-radius: 4px;
      }

      a.xout {
        padding-right: 7px;
        color: #988;
        font-size: 10px;
        text-decoration: none;
        padding-left: 5px;
        font-weight: bold;
      }

      a.xout:hover {
        color: red;
      }

      #instructions iframe {
        width: 100%;
        height: 100%;
      }

      #errorMsg {
        width: 100%;
        color: #a00;
        font-family: Helvetica;
        margin: 3px;
      }

      #objectEditor {
        width: 29%;
        vertical-align: top;
        overflow: scroll;
        font-family: Helvetica;
        display: inline-block;
      }

      #settings {
        width: 69%;
        vertical-align: top;
        overflow: scroll;
        font-family: Helvetica;
        display: inline-block;
        padding: 2px;
      }

    </style>
  </head>
  <body>
    <!--
    <div id="floating-panel">
      <input type="button" value="Toggle Street View" onclick="toggleStreetView();"></input>
    </div>
    -->
    <div id="map"></div>
    <div id="errorMsg"></div>
    <div id="content">
      <div id="settings">
        <p>Click on the map above to place a course marker, checkpoint, or the rallye starting point, then set the object information in the form to the right. Click <b>Preview</b> to see where it will appear on the map and then <b>Confirm</b> to add it to your rallye.</p>

        <p>The <b>Heading</b> is the direction the car must be traveling to see the object (either "north", "south", "east", "west", or 0-360 degrees clockwise from north).</p>

        Rallye Name: <input id="rallyeName" type="text" size=50></input><br />
        <br />
        Grid offset (clockwise degrees from north): <input id="northOffset" oninput="gridOffset();" size=10 value="-10"></input><br />
        <br />
        General Instructions URL: <input id="giURL" type="text" size=70></input><br />
        Route Instructions URL: <input id="riURL" type="text" size=70></input><br />
        Supplemental Instructions URL: <input id="suppURL" type="text" size=70></input><br />
        <br />
        <input type="button" value="Export Rallye" onclick="downloadRallye();"></input>
      </div>
      <div id="objectEditor">
        Latitude: <span id="objectLat"></span><br />
        Longitude: <span id="objectLng"></span><br />
        <br />
        Type: <select id="objectType">
        <option value="cm">Course Marker</option>
        <option value="cp">Checkpoint</option>
        <option value="start">Rallye Start</option>
        </select><br />
        Heading: <input id="objectHeading" type="text" size=21></input><br />
        Label: <input id="objectLabel" type="text" size=25></input><br />
        Checkpoint SI:<br /><textarea id="cpSI" cols=30 rows=4></textarea><br />
        <input type="button" value="Preview" onclick="handleObject();"></input>
        <input type="button" value="Confirm" onclick="handleObject(confirm=true);"></input>
      </div>
    </div>

<script>
var mapObj;
var currMarker;
var currArrow;
var openInfoWindow;

var rallyeStart;
var courseMarkers = {};
var checkpoints = {};

// some variables for headings
// Winters grid about -10 deg off true north,
// so traveling north is 350 and so on
var north = 0
var south = 180
var west = 270
var east = 90

var startLoc = {lat: 38.5261, lng: -121.9648};
//var startLoc = {lat: 38.483338, lng: -121.998583}; //end
var startHeading = 240;

function classLoader() {

class DirectionalMarker extends google.maps.Marker {

  // distance in meters, angle in degrees to one side
  constructor(markerOpts, visibleHeading, visibleDistance=50, visibleAngle=60) {
    super(markerOpts);
    this.visibleDistance = visibleDistance;
    this.visibleHeading = visibleHeading;
    this.visibleAngle = visibleAngle;
  }

  checkVisibility(latlong, heading) {
    if (
      (this.distanceTo(latlong) <= this.visibleDistance ) &&
      (this.angleBetween(heading) <= this.visibleAngle)
    ) {
      this.setVisible(true);
    } else {
      this.setVisible(false);
    }
  }
  
  distanceTo(latlong) {
    return google.maps.geometry.spherical.computeDistanceBetween(
    latlong, this.getPosition());
  }
  
  angleBetween(heading) {
    var diff = Math.abs(this.visibleHeading - heading);
    return Math.min(360-diff, diff);
  }

}

return DirectionalMarker;
}

function placeObjects(map, iconScale=1.0) {
  DirectionalMarker = classLoader();
  
  var obj_markers = [];
  otherObjects.forEach(function(obj) {
    var objIcon = {
      url: obj[3],
      scaledSize: new google.maps.Size(obj[4]*iconScale, obj[5]*iconScale)
    };
    obj_markers.push(
      new DirectionalMarker({
        position: {lat: obj[0], lng: obj[1]},
        map: map,
        icon: objIcon
      },
      obj[6]
      )
    );
  });
  
  return obj_markers;
}

function editObj(objType, title) {

  var lat, lng, selectIdx, heading, label, cpSI;

  switch (objType) {
    case 'cm':
      lat = courseMarkers[title]['lat'];
      lng = courseMarkers[title]['lng'];
      selectIdx = 0;
      heading = courseMarkers[title]['rawHeading'];
      label = title;
      cpSI = '';
      break;
    case 'cp':
      lat = checkpoints[title]['lat'];
      lng = checkpoints[title]['lng'];
      selectIdx = 1;
      heading = checkpoints[title]['rawHeading'];
      label = title;
      cpSI = checkpoints[title]['checkpoint_si'];
      break;
    case 'start':
      lat = rallyeStart['lat'];
      lng = rallyeStart['lng'];
      selectIdx = 2;
      heading = rallyeStart['rawHeading'];
      label = '';
      cpSI = '';
      break;
  }

  document.getElementById("objectType").selectedIndex = selectIdx;
  document.getElementById("objectLat").innerHTML = lat;
  document.getElementById("objectLng").innerHTML = lng;
  document.getElementById("objectHeading").value = heading;
  document.getElementById("objectLabel").value = label;
  document.getElementById("cpSI").value = cpSI;

  // remove the existing object
  removeObj(objType, title);

  // replace it with a preview from the editor
  handleObject();
}

function removeObj(objType, title) {
  if (openInfoWindow) {
    openInfoWindow.close();
    openInfoWindow = null;
  }

  switch (objType) {
    case 'cm':
      courseMarkers[title]['marker_object'].setVisible(false);
      courseMarkers[title]['arrow_object'].setVisible(false);
      delete courseMarkers[title];
      break;
    case 'cp':
      checkpoints[title]['marker_object'].setVisible(false);
      checkpoints[title]['arrow_object'].setVisible(false);
      delete checkpoints[title];
      break;
    case 'start':
      rallyeStart['arrow_object'].setVisible(false);
      rallyeStart = null;
      break;
  }
}

function placeCP(map, lat, lng, heading, title, cpSI, iconScale=1.0) {
  DirectionalMarker = classLoader();

  // sign size to display (pixels)
  var cpWidth = 30*iconScale;
  var cpHeight = 45*iconScale;
  var cpIcon = {
    url: 'https://shaycrk.files.wordpress.com/2018/12/checkpoint.gif',
    scaledSize: new google.maps.Size(cpWidth, cpHeight)
  };
  
  var marker = new DirectionalMarker({
      position: {lat: lat, lng: lng},
      map: map,
      icon: cpIcon,
      title: title
    },
    heading
    )

  var infoWindowObject = new google.maps.InfoWindow;

  var infoWindowHTML = '<b>SI:</b> ' + cpSI;
  infoWindowHTML += '<hr><a href="#" onClick="editObj(\'cp\', \''+title+'\');">Edit</a> | ';
  infoWindowHTML += '<a href="#" onClick="removeObj(\'cp\', \''+title+'\');">Remove</a><br />';

  google.maps.event.addListener(marker, 'click', function() {
    if (openInfoWindow) {
      openInfoWindow.close();
    }
    infoWindowObject.setContent(infoWindowHTML);
    infoWindowObject.open(map, marker);
    openInfoWindow = infoWindowObject;
  });

  return marker;
}

function placeCM(map, lat, lng, heading, title, iconScale=1.0) {
  DirectionalMarker = classLoader();

  // course marker size to display (pixels)
  var cmWidth = 35*iconScale
  var cmHeight = 150*iconScale
  var cmIcon = {
    url: 'https://shaycrk.files.wordpress.com/2018/12/cm_on_pole.gif',
    scaledSize: new google.maps.Size(cmWidth, cmHeight)
  };

  var marker = new DirectionalMarker({
        position: {lat: lat, lng: lng},
        map: map,
        icon: cmIcon,
        title: title
      },
      heading
      );

  var infoWindowObject = new google.maps.InfoWindow;

  var infoWindowHTML = title;
  infoWindowHTML += '<hr><a href="#" onClick="editObj(\'cm\', \''+title+'\');">Edit</a> | ';
  infoWindowHTML += '<a href="#" onClick="removeObj(\'cm\', \''+title+'\');">Remove</a><br />';

  google.maps.event.addListener(marker, 'click', function() {
    if (openInfoWindow) {
      openInfoWindow.close();
    }
    infoWindowObject.setContent(infoWindowHTML);
    infoWindowObject.open(map, marker);
    openInfoWindow = infoWindowObject;
  });

  return marker;
}

function placeArrow(map, lat, lng, angle, height, title=null, color="#a0f") {
  // place an arrow over a map marker, rotated to point a certain direction (e.g., the
  // direction a CM is facing, which is its visibleHeading - 180 deg). It looks like
  // translation by `anchor` is done after rotating the coordinate system, so have
  // to rotate the coordinates of the translation as well. Finally, because rotations
  // happen around the tip of the arrow, translate back (in the original coordinates) 
  // by the size of the arrow to have the center end up where we want it.

  // Two notes that add a little complexity:
  //  1. The coordinate system appears to be left-handed, with greater x-values
  //     further to the west
  //  2. rotations are taken clockwise from due north (the y-axis) as opposed to
  //     polar-coordinates that measure counter-clockwise from the x-axis
  var arrowCenter = new google.maps.Point(0, -2);
  return new google.maps.Marker({
    position: {lat: lat, lng: lng},
    icon: {
      path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
      scale: 2,
      strokeColor: color,
      fillColor: color,
      fillOpacity: 1.0,
      anchor: addPoints(rotateCoordinates(0, height, -1*angle), arrowCenter, subtract=true),
      rotation: angle
    },
    zIndex: 9999,
    title: title,
    map: map
  });
}

function arrowInfoWindow(map, marker, objType, title) {
  var infoWindowObject = new google.maps.InfoWindow;

  var infoWindowHTML = title;
  infoWindowHTML += '<hr><a href="#" onClick="editObj(\''+objType+'\', \''+title+'\');">Edit</a> | ';
  infoWindowHTML += '<a href="#" onClick="removeObj(\''+objType+'\', \''+title+'\');">Remove</a><br />';

  google.maps.event.addListener(marker, 'click', function() {
    if (openInfoWindow) {
      openInfoWindow.close();
    }
    infoWindowObject.setContent(infoWindowHTML);
    infoWindowObject.open(map, marker);
    openInfoWindow = infoWindowObject;
  });
}

function placeArrows(map) {

  courseMarkers.forEach(function(cm) {
    placeArrow(map, cm[0], cm[1], cm[3] - 180, 13, cm[2]);
  });

  checkpoints.forEach(function(cp) {
    placeArrow(map, cp[0], cp[1], cp[3] - 180, 9, cp[2]);
  });

  otherObjects.forEach(function(obj) {
    placeArrow(map, obj[0], obj[1], obj[6] - 180, 13);
  });

}

function getQueryVariable(variable)
{
       var query = window.location.search.substring(1);
       var vars = query.split("&");
       for (var i=0;i<vars.length;i++) {
               var pair = vars[i].split("=");
               if(pair[0] == variable){return pair[1];}
       }
       return(false);
}

function addPoints(p1, p2, subtract=false) {
  var fac = 1.0;
  if (subtract) {
    fac = -1.0;
  }
  return new google.maps.Point(p1.x + fac*p2.x, p1.y + fac*p2.y)
}

function rotateCoordinates(x, y, phi) {
  // phi is a clockwise rotation of the coordinate system,
  // expressed in degrees

  // handle the origin as a special case:
  if ((Math.abs(x) < 1e-6) && (Math.abs(y) < 1e-6)) {
    return new google.maps.Point(0, 0);
  }

  var r = Math.sqrt(x**2 + y**2)
  var theta = Math.atan(y/x)
  if (x < 0) {
    // correct for arctan range
    theta = theta + Math.PI
  }
  var x_prime = r*Math.cos(theta + phi*Math.PI/180)
  var y_prime = r*Math.sin(theta + phi*Math.PI/180)
  return new google.maps.Point(x_prime, y_prime)
}

function initMap() {
  gridOffset();
  initGoogleMap();
}

// map version: view for the rallye master
function initGoogleMap() {
  var map = new google.maps.Map(
    document.getElementById('map'), {
    center: startLoc,
    zoom: 16,
    streetViewControl: true,
    mapTypeControl: false,
    rotateControl: false,
    draggableCursor: 'crosshair'
  });
  mapObj = map;
  
  map.addListener('click', function(e) { 
    if (openInfoWindow) {
      openInfoWindow.close();
      openInfoWindow = null;
    }
    updateEditor(e.latLng.lat(), e.latLng.lng()); 
  });
}

// street view version: actually run the rallye
function initStreetView() {
  var map = new google.maps.StreetViewPanorama(
    document.getElementById('map'), {
    position: startLoc,
    pov: {
      heading: startHeading,
      pitch: 0
    },
    visible: true
  });
  panorama = map;

  markers = placeCMs(map, 1.6);
  markers = markers.concat(placeCPs(map, 1.6));
  markers = markers.concat(placeObjects(map, 1.6));
  
  var center = panorama.getPosition();
  var heading = panorama.getPov().heading;
  markers.forEach(
    function(marker) { marker.checkVisibility(center, heading); }
  );

  panorama.addListener('position_changed', function() {
    center = panorama.getPosition();
    heading = panorama.getPov().heading;
    markers.forEach(
      function(marker) { marker.checkVisibility(center, heading); }
    );
  });

  panorama.addListener('pov_changed', function() {
    center = panorama.getPosition();
    heading = panorama.getPov().heading;
    markers.forEach(
      function(marker) { marker.checkVisibility(center, heading); }
    );
  });

}

function toggleStreetView() {
  var toggle = panorama.getVisible();
  if (toggle == false) {
    panorama.setVisible(true);
  } else {
    panorama.setVisible(false);
  }
}

function checkDistance(center, marker) {
  var markerLatLng = marker.getPosition();
  var distance = google.maps.geometry.spherical.computeDistanceBetween(center, markerLatLng);
  if (distance <= 50.0) {
    marker.setVisible(true);
  } else {
    marker.setVisible(false);
  }
  //console.log(distance);
}

function removeMarker(markerTitle) {
  markers.forEach(function(m) { 
    if ((m.title != null) && (m.title == markerTitle)) { 
      m.setMap(null); 
    } 
  });
}

function setVisibleAngle(markerTitle, newAngle) {
  markers.forEach(function(m) { 
    if ((m.title != null) && (m.title == markerTitle)) { 
      m.visibleAngle = newAngle;
    } 
  });
}

</script>

<script>

function loadInstructions(instruction) {
  // todo: pull in actual content here...
  switch (instruction) {
    case 'web':
      srcURL = 'virtual_rallye_info.pdf';
      break;
    case 'generals':
      srcURL = 'general_instructions.pdf';
      break;
    case 'route':
      srcURL = 'route_instructions.pdf';
      break;
    case 'supps':
      srcURL = 'supplemental_instructions.pdf';
      break;
  }
  document.getElementById("instructions").innerHTML = "<iframe src='"+srcURL+"'></iframe>";

  // remove active class from any current menu item (using array prototype forEach)
  var elms = document.getElementsByClassName("active");
  [].forEach.call(elms, function(s) { s.classList.remove("active"); });

  // add the active class to the clicked menu item
  document.getElementById(instruction).classList.add("active");
}

function cleanInputCM(inputValue) {
  var regex = /[^A-Z0-9]/g;
  return inputValue.toUpperCase().replace(regex, '');
}

function recordCM() {
  // TODO: keep track in a list to allow for scoring? (ideally by sending data to a server so CM point values can remain hidden?)
  var newCM = cleanInputCM(document.getElementById("inputCM").value);
  if (document.getElementById('recordedCM-'+newCM) == null) {
    // only add if not already recorded
    var parent = document.getElementById("scoresheet");
    var newChild = '<div id="recordedCM-'+newCM+'" class="recordedCM"><a href="#" class="xout" onClick="removeCM(\''+newCM+'\');">X</a>'+newCM+'</div>';
    parent.insertAdjacentHTML('beforeend', newChild);
  }
  document.getElementById("inputCM").value = '';

  // if we just recorded M13 ("No Barking") need to fix up direction of CP3 entry...
  // FIXME: find a way to get this out of code!
  if (newCM == 'M13') {
    removeMarker('Checkpoint 2');
    setVisibleAngle('Checkpoint 3', 180);
  }

  return false;
}

function removeCM(toRemove) {
  document.getElementById('recordedCM-'+toRemove).remove();
}

function updateEditor(lat, lng) {
  document.getElementById("objectLat").innerHTML = lat;
  document.getElementById("objectLng").innerHTML = lng;
}

function parseHeading(rawHeading) {
  var heading;
  switch (rawHeading) {
    case 'north':
      heading = north;
      break;
    case 'south':
      heading = south;
      break;
    case 'east':
      heading = east;
      break;
    case 'west':
      heading = west;
      break;
    default:
      heading = parseFloat(rawHeading);
  }
  return heading;
}

function gridOffset() {
  var offset = parseFloat(document.getElementById("northOffset").value) || 0;
  north = 0 + offset;
  south = 180 + offset;
  east = 90 + offset;
  west = 270 + offset;

  Object.keys(courseMarkers).forEach(function(key) {
    courseMarkers[key]['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj, 
      courseMarkers[key]['lat'], 
      courseMarkers[key]['lng'], 
      parseHeading(courseMarkers[key]['rawHeading'])-180, 
      13, 
      courseMarkers[key]['label']
    );
    courseMarkers[key]['arrow_object'] = newArrow;
  });

  Object.keys(checkpoints).forEach(function(key) {
    checkpoints[key]['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj, 
      checkpoints[key]['lat'], 
      checkpoints[key]['lng'], 
      parseHeading(checkpoints[key]['rawHeading'])-180, 
      9, 
      checkpoints[key]['label']
    );
    checkpoints[key]['arrow_object'] = newArrow;
  });

  if (rallyeStart) {
    rallyeStart['arrow_object'].setVisible(false);
    newArrow = placeArrow(
      mapObj, 
      rallyeStart['lat'], 
      rallyeStart['lng'], 
      parseHeading(rallyeStart['rawHeading']), 
      0, 
      'Rallye Start',
      "#006400"
    );
    rallyeStart['arrow_object'] = newArrow;
  }

}

function showError(errorText) {
  document.getElementById("errorMsg").innerHTML = errorText;
}

function handleObject(confirm=false) {
  var objType = document.getElementById("objectType").value;
  var lat = parseFloat(document.getElementById("objectLat").textContent);
  var lng = parseFloat(document.getElementById("objectLng").textContent);
  var rawHeading = document.getElementById("objectHeading").value.toLowerCase();
  var heading = parseHeading(rawHeading);
  var label = document.getElementById("objectLabel").value.replace("\\n", "\n");
  var cpSI = document.getElementById("cpSI").value;

  // clear any current error
  showError('');

  if (!lat || !lng || rawHeading == '') {
    showError('ERROR: Specify a location and heading!');
    return false;
  }

  if (currMarker) {
    currMarker.setVisible(false);
    currMarker = null;
  }

  if (currArrow) {
    currArrow.setVisible(false);
    currArrow = null;
  }

  switch (objType) {
    case 'cm':
      if (courseMarkers[label]) {
        showError('ERROR: Course marker '+label+' already exists!');
      } else if (!label) {
        showError('ERROR: Must specify a label for the course marker');
      } else {
        currMarker = placeCM(mapObj, lat, lng, heading, label, 0.3);
        currArrow = placeArrow(mapObj, lat, lng, heading-180, 13, label);
        arrowInfoWindow(mapObj, currArrow, 'cm', label);
        if (confirm) {
          courseMarkers[label] = {
            'label': label,
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'marker_object': currMarker,
            'arrow_object': currArrow
          };
        }
      }
      break;
    case 'cp':
      if (checkpoints[label]) {
        showError('ERROR: Checkpoint '+label+' already exists!');
      } else if (!label || !cpSI) {
        showError('ERROR: Specify a label and SI for the checkpoint');
      } else {
        currMarker = placeCP(mapObj, lat, lng, heading, label, cpSI, 0.3);
        currArrow = placeArrow(mapObj, lat, lng, heading-180, 9, label);
        if (confirm) {
          checkpoints[label] = {
            'label': label,
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'checkpoint_si': cpSI,
            'marker_object': currMarker,
            'arrow_object': currArrow
          };
        }
      }
      break;
    case 'start':
      if (rallyeStart) {
        showError("ERROR: Start already exists!");
      } else {
        currArrow = placeArrow(mapObj, lat, lng, heading, 0, 'Rallye Start', "#006400");
        arrowInfoWindow(mapObj, currArrow, 'start', 'Rallye Start');
        if (confirm) {
          rallyeStart = {
            'lat': lat,
            'lng': lng,
            'rawHeading': rawHeading,
            'arrow_object': currArrow
          }
        }
      }
      break;
  }

  if (confirm) {
    // these have been added to the global vars, so remove them
    currMarker = null;
    currArrow = null;

    // reset the object editor form
    document.getElementById("objectType").selectedIndex = 0;
    document.getElementById("objectLat").innerHTML = '';
    document.getElementById("objectLng").innerHTML = '';
    document.getElementById("objectHeading").value = '';
    document.getElementById("objectLabel").value = '';
    document.getElementById("cpSI").value = '';
  }
}

function rallyeToJSON() {
  var rallyeName = document.getElementById("rallyeName").value;
  if (!rallyeStart || !rallyeName) {
    showError('ERROR: Set a name and starting point before exporting!');
    return;
  }

  var cms = [];
  Object.keys(courseMarkers).forEach(function(key) {
    cms.push([
      courseMarkers[key]['lat'],
      courseMarkers[key]['lng'],
      courseMarkers[key]['label'],
      courseMarkers[key]['rawHeading']
      ]);
  });

  var cps = [];
  Object.keys(checkpoints).forEach(function(key) {
    cps.push([
      checkpoints[key]['lat'],
      checkpoints[key]['lng'],
      checkpoints[key]['label'],
      checkpoints[key]['rawHeading'],
      '<b>SI:</b> ' + checkpoints[key]['checkpoint_si']
      ]);
  });

  var d = {
    'rallyeName': rallyeName,
    'gridOffset': parseFloat(document.getElementById("northOffset").value) || 0,
    'generalsURL': document.getElementById("giURL").value,
    'routeURL': document.getElementById("riURL").value,
    'suppsURL': document.getElementById("suppURL").value,
    'rallye_start': {
      lat: rallyeStart['lat'],
      lng: rallyeStart['lng'],
      heading: rallyeStart['rawHeading']
    },
    'courseMarkers': cms,
    'checkpoints': cps
  }

  return JSON.stringify(d);
}

// from: https://stackoverflow.com/questions/14964035/how-to-export-javascript-array-info-to-csv-on-client-side
// The download function takes a data string, the filename and mimeType as parameters
function downloadFile(content, fileName, mimeType) {
  var a = document.createElement('a');
  mimeType = mimeType || 'application/octet-stream';

  if (navigator.msSaveBlob) { // IE10
    navigator.msSaveBlob(new Blob([content], {
      type: mimeType
    }), fileName);
  } else if (URL && 'download' in a) { //html5 A[download]
    a.href = URL.createObjectURL(new Blob([content], {
      type: mimeType
    }));
    a.setAttribute('download', fileName);
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  } else {
    location.href = 'data:application/octet-stream,' + encodeURIComponent(content); // only this mime type is supported
  }
}

function downloadRallye() {
  var fileName = document.getElementById("rallyeName").value + '.json';
  downloadFile(rallyeToJSON(), fileName, 'text/plain;encoding:utf-8');
}



</script>

    <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC3-5-mUDJ2dfNR3l-8u_g2_XCBOeNbJvU&libraries=geometry&callback=initMap">
    </script>
  </body>
